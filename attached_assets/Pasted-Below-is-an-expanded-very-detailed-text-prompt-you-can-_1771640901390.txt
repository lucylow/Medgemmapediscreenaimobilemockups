Below is an expanded, very detailed text prompt you can drop into Replit/Cursor as the “project system prompt” or “spec” for your React Native (TypeScript) PediScreen AI mobile app. It focuses on structure, components, hooks, and data flows, with clear TODOs for backend/native bits.
You can treat it as the authoritative blueprint for the AI coding agent.

Global Role & Goals
You are an expert React Native + TypeScript engineer, healthcare UX designer, and safety engineer building a cross‑platform mobile app (iOS + Android) for the:
MedGemma Impact Challenge (Kaggle)
Project: PediScreen AI – Pediatric Screening Assistant
The app must:
Be easy to develop and run on Replit + Expo (React Native, web preview where possible).
Target parents, community health workers (CHWs), and clinicians.
Capture pediatric developmental screening data.
Integrate with a backend that uses MedSigLIP + MedGemma (and Gemma 3 for caregiver wording).
Enforce human‑in‑the‑loop (HITL) and safety (no autonomous diagnosis).
Use modern React Native + TypeScript architecture with clear file layout, navigation, screens, components, hooks, and data flows.
You are not required to make every line of code runnable; focus on clear architecture, good patterns, and explicit TODOs where real integrations plug in.

Technical Stack & Constraints
UI framework: React Native (Expo is preferred for Replit; assume Expo Router or classic React Navigation).
Language: TypeScript.
State: React hooks + lightweight context; you do not need Redux or heavy state libs.
Navigation: React Navigation or Expo Router tabs + stacks.
Storage: AsyncStorage wrapper for local persistence (mocked if needed).
Network: Fetch/axios via a small API client; backend URL configurable and easy to stub/mimic.
Dev environment: Must be understandable and usable from Replit:
A single npm install / yarn install.
npm run start to run expo dev server.
When in doubt, favor:
Simpler, explicit code.
Components that are easy to modify in a hackathon setting.
Clear comments and TODO markers over clever abstractions.

High‑Level App Concept
User roles:
Parent/Caregiver
Community Health Worker (CHW)
Clinician (demo/read‑only mode)
Key flows:
Child management
View child list.
Add/edit child profile with minimal personal data.
Screening session
Select child + age band (e.g., 9, 18, 24, 36 months).
Answer milestone‑style questions per domain:
Communication
Gross Motor
Fine Motor
Social‑Emotional
Cognitive/Problem Solving
Optional free‑text observations.
Optional images (drawings, photos) via camera/gallery.
Submit to backend
Send structured payload to /api/screening.
Receive a screening summary (non‑diagnostic).
Display results
Domain‑level risk: On Track / Monitor / Discuss / Refer (screening labels).
Plain‑language summary for caregivers.
Suggested actions and follow‑up timing.
Timeline
Show history of screenings for each child (trend of risk over time).
Clinician demo view
Show AI draft vs clinician‑approved text (can be mocked).
Emphasize HITL in the UI.

Safety & Regulatory Constraints (For All Code & Copy)
Scope: Developmental screening, not diagnosis.
Prohibited: Displaying diagnostic labels like “autism”, “ADHD”, “global developmental delay”.
Language: Use phrases like:
“Screening suggests…”
“May benefit from monitoring or discussion with a health professional.”
“Not a diagnosis.”
UI disclaimer: On key screens (screening intro, results, clinician demo), include persistent text:
PediScreen AI supports developmental screening only and does not make diagnoses. Always discuss concerns with a licensed health professional.
Do not implement any emergency triage or urgent‑care promises.
Keep data minimal; no full names or exact addresses required.

Project Structure & Files
Design a clear folder layout:
text
root/
  app.json            # Expo config (if using Expo)
  package.json
  tsconfig.json
  babel.config.js
  App.tsx


  src/
    navigation/
      RootNavigator.tsx
      types.ts


    screens/
      WelcomeScreen.tsx
      RoleSelectScreen.tsx
      ChildListScreen.tsx
      ChildFormScreen.tsx
      ScreeningIntroScreen.tsx
      ScreeningDomainSelectScreen.tsx
      ScreeningQuestionsScreen.tsx
      ScreeningMediaScreen.tsx
      ScreeningReviewScreen.tsx
      ScreeningResultScreen.tsx
      TimelineScreen.tsx
      ClinicianReviewScreen.tsx
      SettingsScreen.tsx
      DemoCasesScreen.tsx


    components/
      layout/
        ScreenContainer.tsx
        AppHeader.tsx
        AppSafeAreaView.tsx
      ui/
        PrimaryButton.tsx
        SecondaryButton.tsx
        TextField.tsx
        TextArea.tsx
        TogglePill.tsx
        DomainPill.tsx
        RiskBadge.tsx
        Tag.tsx
        Card.tsx
      screening/
        QuestionCard.tsx
        DomainProgressBar.tsx
        ResultCard.tsx
        NextStepsList.tsx
        TimelineItem.tsx
      common/
        DisclaimerFooter.tsx
        LoadingOverlay.tsx
        ErrorState.tsx
        EmptyState.tsx


    hooks/
      useScreeningSession.ts
      useChildrenStore.ts
      useApiClient.ts
      useMockMode.ts
      useTheme.ts


    api/
      client.ts
      endpoints.ts
      types.ts


    context/
      ScreeningSessionContext.tsx


    theme/
      colors.ts
      typography.ts
      spacing.ts
      shadows.ts


    utils/
      validation.ts
      formatting.ts
      asyncStorage.ts
      demoData.ts
      ageUtils.ts


    config/
      env.ts
      flags.ts

Add TODO comments wherever external or native integration is implied.

Core TypeScript Types
Define shared types under src/api/types.ts and reused in screens/hooks:
ts
// src/api/types.ts


export type UserRole = 'caregiver' | 'chw' | 'clinician';


export interface Child {
  id: string;
  displayName: string;      // nickname or initials, not full legal name
  birthDate: string;        // ISO string
  sex?: 'male' | 'female' | 'other' | 'prefer_not_to_say';
  primaryLanguage?: string;
}


export type DomainId = 'communication' | 'gross_motor' | 'fine_motor' | 'social' | 'cognitive';


export interface Question {
  id: string;
  domain: DomainId;
  prompt: string;
  helperText?: string;
  ageBand: string; // "18-24", "24-36", etc.
}


export type QuestionAnswerValue = 'yes' | 'sometimes' | 'not_yet' | null;


export interface QuestionAnswer {
  questionId: string;
  value: QuestionAnswerValue;
}


export interface DomainAnswers {
  domain: DomainId;
  answers: QuestionAnswer[];
}


export interface MediaAttachment {
  id: string;
  kind: 'photo' | 'drawing' | 'video_frame';
  uri: string;         // local URI
  description?: string;
}


export type ScreeningStatus = 'draft' | 'submitted' | 'reviewed';


export interface ScreeningSession {
  id: string;
  childId: string;
  ageMonths: number;
  createdAt: string;
  role: UserRole;
  domains: DomainAnswers[];
  parentConcernsText: string;
  media: MediaAttachment[];
  status: ScreeningStatus;
}


export type RiskLevel = 'on_track' | 'monitor' | 'discuss' | 'refer';


export interface DomainRiskSummary {
  domain: DomainId;
  risk: RiskLevel;
  summary: string;         // clinician-facing summary
  parentSummary: string;   // caregiver wording
}


export interface ScreeningResult {
  sessionId: string;
  overallRisk: RiskLevel;
  overallSummary: string;
  domainRisks: DomainRiskSummary[];
  nextSteps: string[];
  parentSummary: string;
  clinicianSummary: string;
  modelProvenance: {
    modelId: string;
    version: string;
  };
  safetyFlags?: string[]; // e.g. ['no_diagnosis_terms', 'pass']
}


Navigation & App Root
Use a root stack navigator with tabs (or Expo Router equivalent). The structure is:
Root stack:
Welcome → RoleSelect → Tab Navigator
Tab navigator (main app):
Home (Child list, screening start)
Timeline
Demo
Settings
Example skeleton:
tsx
// src/navigation/RootNavigator.tsx


import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import WelcomeScreen from '../screens/WelcomeScreen';
import RoleSelectScreen from '../screens/RoleSelectScreen';
import ChildListScreen from '../screens/ChildListScreen';
// ... other imports


export type RootStackParamList = {
  Welcome: undefined;
  RoleSelect: undefined;
  MainTabs: undefined;
  ScreeningIntro: { childId: string };
  ScreeningDomainSelect: { childId: string; ageMonths: number };
  ScreeningQuestions: { sessionId: string; domain: DomainId };
  ScreeningMedia: { sessionId: string };
  ScreeningReview: { sessionId: string };
  ScreeningResult: { sessionId: string };
};


const Stack = createNativeStackNavigator<RootStackParamList>();
const Tab = createBottomTabNavigator();


function MainTabs() {
  return (
    <Tab.Navigator>
      <Tab.Screen name="Home" component={ChildListScreen} />
      <Tab.Screen name="Timeline" component={TimelineScreen} />
      <Tab.Screen name="Demo" component={DemoCasesScreen} />
      <Tab.Screen name="Settings" component={SettingsScreen} />
    </Tab.Navigator>
  );
}


export const RootNavigator = () => (
  <NavigationContainer>
    <Stack.Navigator>
      <Stack.Screen name="Welcome" component={WelcomeScreen} options={{ headerShown: false }} />
      <Stack.Screen name="RoleSelect" component={RoleSelectScreen} options={{ title: 'Who is using the app?' }} />
      <Stack.Screen name="MainTabs" component={MainTabs} options={{ headerShown: false }} />
      {/* Screening flow screens */}
      <Stack.Screen name="ScreeningIntro" component={ScreeningIntroScreen} />
      <Stack.Screen name="ScreeningDomainSelect" component={ScreeningDomainSelectScreen} />
      <Stack.Screen name="ScreeningQuestions" component={ScreeningQuestionsScreen} />
      <Stack.Screen name="ScreeningMedia" component={ScreeningMediaScreen} />
      <Stack.Screen name="ScreeningReview" component={ScreeningReviewScreen} />
      <Stack.Screen name="ScreeningResult" component={ScreeningResultScreen} />
    </Stack.Navigator>
  </NavigationContainer>
);

In App.tsx, wrap the navigator with providers:
tsx
// App.tsx


import React from 'react';
import { RootNavigator } from './src/navigation/RootNavigator';
import { ScreeningSessionProvider } from './src/context/ScreeningSessionContext';
import { ThemeProvider } from './src/hooks/useTheme';


export default function App() {
  return (
    <ThemeProvider>
      <ScreeningSessionProvider>
        <RootNavigator />
      </ScreeningSessionProvider>
    </ThemeProvider>
  );
}


Key Screens & Responsibilities
WelcomeScreen
Short, friendly introduction.
Button: “Get Started”.
Shows brief copy about what the app does and safety disclaimer.
RoleSelectScreen
Ask: “Who is using the app today?”
Caregiver / Parent
Community Health Worker
Clinician (demo mode)
Store selected role in context or local state; used to:
Adjust copy tone.
Show or hide Clinician Review tab.
ChildListScreen
List of child profiles.
“Add child” button → ChildFormScreen.
Tap a child → show child detail, last screening summary, and “Start new screening” (which goes to ScreeningIntro).
ChildFormScreen
Form fields:
Nickname / display name.
Birth month/year (or date).
Optional: sex, primary language.
On save:
Validate minimal data.
Use AsyncStorage to persist.
ScreeningIntroScreen
Show selected child and computed age in months.
Brief explanation:
What this screening is.
How long it takes.
That it’s not diagnostic.
Button: “Start Screening”.
Option to adjust age band if needed (e.g., corrected age for preterm).
ScreeningDomainSelectScreen
Show domains as cards/pills with icons.
For simplicity, you can automatically include all relevant domains for age, but still display them.
Show progress indicator (0 of N domains answered).
Tapping a domain navigates to ScreeningQuestionsScreen for that domain.
ScreeningQuestionsScreen
Show one domain’s questions in a paginated or scrollable list.
For each question:
Use QuestionCard component:
Prompt.
“Yes”, “Sometimes”, “Not yet” buttons.
Show progress: “Question 3 of 7”.
Navigation:
“Previous”/“Next” or “Save & Continue”.
On leaving domain:
Save answers in ScreeningSessionContext.
ScreeningMediaScreen
Optional screen.
Explain:
User may take/show a photo of a drawing or short video of an activity, but it’s optional.
Provide buttons:
“Add photo” (TODO: camera/gallery integration).
“Skip for now”.
For Replit friendliness:
Use placeholder components and TODO comments for camera integration:
tsx
// TODO: Integrate expo-image-picker or similar for real camera/gallery support.


ScreeningReviewScreen
Summarize:
Child.
Age.
Domains and answered questions (with simple icon for missing answers).
Parent concern free‑text.
Media preview thumbnails.
Allow editing:
“Edit answers” (per domain).
“Edit parent observations”.
Show consent text + checkbox:
“I understand this is a screening tool and not a diagnosis.”
Submit button:
Trigger backend or mock API call.
ScreeningResultScreen
Show RiskBadge for overall and per domain.
Present parent‑facing summary:
Use ResultCard and NextStepsList.
Include disclaimers and guidance:
“Take this summary to your child’s doctor or nurse.”
Provide “Save to history” (local storage) and “Start new screening” options.
Also show a section labelled “For your clinician” with slightly more technical phrasing (but still safe).
TimelineScreen
Show list of past screenings per child:
Date, age, overall risk.
Selecting an item shows mini summary (yoy trend).
This can be simple FlatList + TimelineItem.
ClinicianReviewScreen (demo)
Mock list of pending AI drafts:
Show AI suggested risk and summary.
Provide static view of:
“AI draft (not shown to families)”.
“Clinician‑approved wording”.
This demonstrates HITL even if not wired to real backend.
SettingsScreen
Toggles:
“Use mock API responses” (for demo).
“Clear local data”.
Backend URL input (optional, text field with default value).
DemoCasesScreen
Preconfigured demo cases:
Buttons for:
“18 months – On Track”
“24 months – Communication Monitor”
“36 months – Fine Motor Discuss”
“24 months – Multi‑domain Refer”
Clicking loads prefilled ScreeningResult into ScreeningResultScreen for instant demo.

Core Components
ScreenContainer
Wraps screens with safe area, padding, and background:
tsx
// src/components/layout/ScreenContainer.tsx
import React from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';


export const ScreenContainer: React.FC<{ scroll?: boolean; children: React.ReactNode }> = ({
  scroll,
  children,
}) => {
  if (scroll) {
    return (
      <ScrollView contentContainerStyle={styles.container}>
        {children}
      </ScrollView>
    );
  }
  return <View style={styles.container}>{children}</View>;
};


const styles = StyleSheet.create({
  container: {
    flexGrow: 1,
    paddingHorizontal: 16,
    paddingVertical: 12,
  },
});

QuestionCard
Displays a single milestone question with 3‑option answer:
tsx
// src/components/screening/QuestionCard.tsx
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { PrimaryButton } from '../ui/PrimaryButton';
import { QuestionAnswerValue } from '../../api/types';


interface Props {
  prompt: string;
  helperText?: string;
  value: QuestionAnswerValue;
  onChange: (value: QuestionAnswerValue) => void;
}


export const QuestionCard: React.FC<Props> = ({ prompt, helperText, value, onChange }) => {
  return (
    <View style={styles.card}>
      <Text style={styles.prompt}>{prompt}</Text>
      {helperText ? <Text style={styles.helper}>{helperText}</Text> : null}
      <View style={styles.buttonsRow}>
        {/* You can reuse a TogglePill component for each option */}
        <PrimaryButton
          label="Yes"
          variant={value === 'yes' ? 'filled' : 'outline'}
          onPress={() => onChange('yes')}
        />
        <PrimaryButton
          label="Sometimes"
          variant={value === 'sometimes' ? 'filled' : 'outline'}
          onPress={() => onChange('sometimes')}
        />
        <PrimaryButton
          label="Not yet"
          variant={value === 'not_yet' ? 'filled' : 'outline'}
          onPress={() => onChange('not_yet')}
        />
      </View>
    </View>
  );
};


const styles = StyleSheet.create({
  card: { marginVertical: 8, padding: 12, borderRadius: 12, backgroundColor: '#fff' },
  prompt: { fontSize: 16, fontWeight: '600', marginBottom: 4 },
  helper: { fontSize: 14, color: '#555', marginBottom: 8 },
  buttonsRow: { flexDirection: 'row', justifyContent: 'space-between' },
});

RiskBadge
Simple risk indicator:
tsx
// src/components/ui/RiskBadge.tsx
const riskColors: Record<RiskLevel, string> = {
  on_track: '#22c55e',
  monitor: '#facc15',
  discuss: '#f97316',
  refer: '#ef4444',
};


const riskLabels: Record<RiskLevel, string> = {
  on_track: 'On Track',
  monitor: 'Monitor',
  discuss: 'Discuss with provider',
  refer: 'Consider referral',
};


export const RiskBadge: React.FC<{ risk: RiskLevel }> = ({ risk }) => (
  <View style={[styles.badge, { backgroundColor: riskColors[risk] }]}>
    <Text style={styles.text}>{riskLabels[risk]}</Text>
  </View>
);

DisclaimerFooter
Shown at bottom of sensitive screens:
tsx
// src/components/common/DisclaimerFooter.tsx
export const DisclaimerFooter = () => (
  <View style={styles.container}>
    <Text style={styles.text}>
      PediScreen AI supports developmental screening only and does not make diagnoses. Always
      discuss concerns with a licensed health professional.
    </Text>
  </View>
);


Hooks & Context
useScreeningSession
Hook to manage the current session in memory:
ts
// src/hooks/useScreeningSession.ts
import { useContext } from 'react';
import { ScreeningSessionContext } from '../context/ScreeningSessionContext';


export const useScreeningSession = () => useContext(ScreeningSessionContext);

ScreeningSessionContext
Stores the mutable session; provides actions:
tsx
// src/context/ScreeningSessionContext.tsx
import React, { createContext, useState, useMemo } from 'react';
import { ScreeningSession, DomainId, QuestionAnswerValue, DomainAnswers } from '../api/types';
import { v4 as uuidv4 } from 'uuid';


interface ScreeningSessionContextValue {
  currentSession: ScreeningSession | null;
  startSession: (childId: string, ageMonths: number, role: UserRole) => void;
  setAnswer: (domain: DomainId, questionId: string, value: QuestionAnswerValue) => void;
  setParentConcerns: (text: string) => void;
  addMedia: (attachment: MediaAttachment) => void;
  clearSession: () => void;
}


export const ScreeningSessionContext = createContext<ScreeningSessionContextValue>(
  {} as ScreeningSessionContextValue
);


export const ScreeningSessionProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [currentSession, setCurrentSession] = useState<ScreeningSession | null>(null);


  const startSession = (childId: string, ageMonths: number, role: UserRole) => {
    const newSession: ScreeningSession = {
      id: uuidv4(),
      childId,
      ageMonths,
      createdAt: new Date().toISOString(),
      role,
      domains: [],
      parentConcernsText: '',
      media: [],
      status: 'draft',
    };
    setCurrentSession(newSession);
  };


  const setAnswer = (domain: DomainId, questionId: string, value: QuestionAnswerValue) => {
    if (!currentSession) return;
    const domains = [...currentSession.domains];
    let d = domains.find((x) => x.domain === domain);
    if (!d) {
      d = { domain, answers: [] };
      domains.push(d);
    }
    const idx = d.answers.findIndex((a) => a.questionId === questionId);
    if (idx >= 0) d.answers[idx].value = value;
    else d.answers.push({ questionId, value });
    setCurrentSession({ ...currentSession, domains });
  };


  const setParentConcerns = (text: string) => {
    if (!currentSession) return;
    setCurrentSession({ ...currentSession, parentConcernsText: text });
  };


  const addMedia = (attachment: MediaAttachment) => {
    if (!currentSession) return;
    setCurrentSession({ ...currentSession, media: [...currentSession.media, attachment] });
  };


  const clearSession = () => setCurrentSession(null);


  const value = useMemo(
    () => ({ currentSession, startSession, setAnswer, setParentConcerns, addMedia, clearSession }),
    [currentSession]
  );


  return <ScreeningSessionContext.Provider value={value}>{children}</ScreeningSessionContext.Provider>;
};


API Client & Mock Mode
Config & Flags
ts
// src/config/env.ts
export const API_BASE_URL = process.env.EXPO_PUBLIC_API_BASE_URL || 'https://example.com';


// src/config/flags.ts
export const USE_MOCK_API = true; // TODO: toggle via Settings in UI

client.ts
ts
// src/api/client.ts
import { ScreeningSession, ScreeningResult } from './types';
import { USE_MOCK_API } from '../config/flags';
import { mockScreeningResult } from '../utils/demoData';


export async function submitScreening(session: ScreeningSession): Promise<ScreeningResult> {
  if (USE_MOCK_API) {
    // Simulate network delay
    await new Promise((res) => setTimeout(res, 800));
    return mockScreeningResult(session);
  }


  // TODO: Implement real network call
  const res = await fetch(`${API_BASE_URL}/api/screening`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(session),
  });


  if (!res.ok) {
    throw new Error('Failed to submit screening');
  }


  const data = (await res.json()) as ScreeningResult;
  return data;
}

demoData.ts
Provide sample mock results:
ts
// src/utils/demoData.ts
import { ScreeningSession, ScreeningResult } from '../api/types';


export function mockScreeningResult(session: ScreeningSession): ScreeningResult {
  // Use age/domain info for simple heuristics for demo:
  // e.g., always "Monitor" communication for 24 month sessions.
  const overallRisk: RiskLevel = 'monitor';
  return {
    sessionId: session.id,
    overallRisk,
    overallSummary: 'Screening suggests one area to monitor more closely.',
    domainRisks: [
      {
        domain: 'communication',
        risk: 'monitor',
        summary: 'Expressive language is slightly below expectations based on your answers.',
        parentSummary:
          'Some of your child’s talking skills may be emerging a bit later. This is common, but it can help to watch closely and talk with your provider.',
      },
      // ... other domains with 'on_track'
    ],
    nextSteps: [
      'Try daily talking and reading activities.',
      'Repeat this screening in 3 months.',
      'Share this summary with your child’s doctor.',
    ],
    parentSummary:
      'This screening suggests your child is doing well in many areas, with one communication area to watch more closely.',
    clinicianSummary:
      'Screening indicates borderline expressive language skills for age. Recommend monitoring, parent‑led language stimulation, and repeat screening in 3 months.',
    modelProvenance: {
      modelId: 'medgemma-pediscreen-lora-v1',
      version: '1.0.0',
    },
    safetyFlags: ['no_diagnosis_terms', 'pass'],
  };
}


TODO Markers for Backend / Native
In your generated code, clearly annotate integration points:
Camera/gallery:
tsx
// TODO: Integrate expo-image-picker or react-native-image-picker
// For Replit demo, use a static placeholder image or mock object


Secure storage:
ts
// TODO: For production, consider encrypted storage instead of AsyncStorage


Real backend:
ts
// TODO: Replace API_BASE_URL and submitScreening implementation
// with actual MedGemma backend endpoint when available.


Auth (if any):
ts
// TODO: Optional: add simple token or API key auth for clinician mode.


This keeps the code self‑documenting for future completion.

Developer Experience & Replit Notes
Provide scripts in package.json:
json
{
  "scripts": {
    "start": "expo start",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web"
  }
}


Keep dependencies minimal:
"expo", "react", "react-native", "@react-navigation/native", stack/tab navigator, @react-native-async-storage/async-storage, and uuid.
Document in a short README_mobile.md:
How to run in Replit.
How to toggle mock mode.
Which flows to show in a 3‑minute demo (parent path + clinician demo).

Using this prompt, produce:
A complete TypeScript React Native codebase skeleton.
Implemented screens, components, hooks, and data flows sketched above.
Clear TODOs for real MedGemma backend and native modules.
Safe, parent‑friendly copy and strong HITL messaging throughout.


